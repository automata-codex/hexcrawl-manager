---
import { getCollection, getEntry, render } from 'astro:content';

import { getCluePath } from '../config/routes';
import { renderBulletMarkdown } from '../utils/markdown';

const allClues = await getCollection('clues');

import StatBlock from './StatBlock/StatBlock.astro';

import type { DungeonEntry } from '../types';

interface Props {
  dungeon: DungeonEntry;
  isSubcomponent?: boolean;
}

const { dungeon, isSubcomponent = false } = Astro.props;
const hexData = await getEntry('hexes', dungeon.data.hexId);
if (!hexData) {
  throw new Error('Hex not found: ' + dungeon.data.hexId);
}

const { Content } = await render(dungeon);

const statBlockData = await getCollection('statBlocks');

async function getStatBlocks(statBlockIds: string[]) {
  const output = statBlockIds.map(async (id) => {
    const statBlock = statBlockData.find((statBlock) => statBlock.id === id);
    if (!statBlock) {
      throw new Error('Stat block not found: ' + id);
    }
    return statBlock.data;
  });
  return Promise.all(output);
}

const statBlocks = dungeon.data.statBlocks
  ? await getStatBlocks(dungeon.data.statBlocks)
  : [];

// Build clue list
const dungeonClueIds = dungeon.data.clues ?? [];
const clueList = dungeonClueIds.map((clueId) => {
  const clue = allClues.find((c) => c.id === clueId);
  return {
    id: clueId,
    name: clue?.data.name ?? clueId,
    found: !!clue,
  };
});
---

<style>
  .description-header {
    display: none;
  }

  .dungeon-data-bar {
    display: flex;
  }

  .dungeon-data-bar > div {
    font-weight: bold;
    margin-right: 1rem;
  }

  .dungeon-source {
    font-weight: bold;
  }

  .maps {
    font-weight: bold;
  }

  .spacer {
    margin-bottom: 1rem;
  }
</style>
<div class="dungeon-data-bar">
  <div>
    Hex:
    <a href={`/session-toolkit/hexes/${hexData.id}`}>
      {
        renderBulletMarkdown(
          `${hexData.data.id.toUpperCase()} "${hexData.data.name}"`,
        )
      }
    </a>
  </div>
  {
    isSubcomponent && (
      <div>
        <a href={`/gm-reference/dungeons/${dungeon.id}`}>View Dungeon</a>
      </div>
    )
  }
</div>
{
  dungeon.data.source && (
    <div class="dungeon-source">
      Source: <Fragment set:html={renderBulletMarkdown(dungeon.data.source)} />
    </div>
  )
}
{
  dungeon.data.images && (
    <div>
      <p class="maps">Maps:</p>
      <ul>
        {dungeon.data.images.map((image) => (
          <li>
            <a
              href={`/images/maps/dungeons/${image.filename}`}
              target="_blank"
              rel="noopener noreferrer"
            >
              {image.description}
            </a>
          </li>
        ))}
      </ul>
    </div>
  )
}
{
  clueList.length > 0 && (
    <p>
      <strong>Clues</strong> in this dungeon:{' '}
      {clueList.map((clue, i) => (
        <>
          {clue.found ? (
            <a href={getCluePath(clue.id)}>{clue.name}</a>
          ) : (
            <span class="has-text-danger">{clue.name} (not found)</span>
          )}
          {i < clueList.length - 1 && ', '}
        </>
      ))}
    </p>
  )
}
<div class="spacer"></div>
<h2 class="description-header">Description</h2>
<div class="dungeon-content">
  {isSubcomponent ? dungeon.data.summary : <Content />}
</div>
{
  !isSubcomponent && statBlocks.length > 0 && (
    <div>
      <h2 class="title is-3">Stat Blocks</h2>
      {statBlocks.map((statBlock) => (
        <StatBlock data={statBlock} />
      ))}
    </div>
  )
}
{
  isSubcomponent && (
    <script>
      const container = document.querySelector('.dungeon-content'); const offset
      = 1; // shift down by 1 level if (container){' '}
      {container!.querySelectorAll('h1, h2, h3, h4, h5, h6').forEach((el) => {
        const tagLevel = parseInt(el.tagName[1]);
        const visualLevel = Math.min(tagLevel + offset, 6);
        el.setAttribute('role', 'heading');
        el.setAttribute('aria-level', visualLevel.toString());
      })}
    </script>
  )
}
