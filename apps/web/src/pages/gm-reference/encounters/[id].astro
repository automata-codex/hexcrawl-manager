---
import { getCollection, getEntry } from 'astro:content';

import EncounterContent from '../../../components/EncounterContent.astro';
import RoleplayBook from '../../../components/RoleplayBook/RoleplayBook.astro';
import StatBlock from '../../../components/StatBlock/StatBlock.astro';
import Unlocks from '../../../components/Unlocks.svelte';
import {
  getDungeonPath,
  getFloatingCluePath,
  getHexPath,
  getPointcrawlEdgePath,
  getPointcrawlNodePath,
  getPointcrawlPath,
  getRegionPath,
} from '../../../config/routes';
import SecretArticleLayout from '../../../layouts/SecretArticleLayout.astro';
import { getFlatKnowledgeTrees } from '../../../utils/knowledge-trees';
import { loadAugmentedEncounter } from '../../../utils/load-augmented-encounters';
import {
  renderBulletMarkdown,
  renderMarkdown,
} from '../../../utils/markdown';

import type { FloatingClueEntry } from '../../../types';
import type { EncounterData } from '@skyreach/schemas';

const flatKnowledgeTrees = await getFlatKnowledgeTrees();

// Get the ID from the incoming server request
const { id } = Astro.params;
if (!id) {
  return new Response(null, {
    status: 404,
    statusText: 'Not found',
  });
}

// Query for the entry directly using the request slug
const encounterData = await getEntry('encounters', id);

// Redirect if the entry does not exist
if (encounterData === undefined) {
  return new Response(null, {
    status: 404,
    statusText: 'Not found',
  });
}

const encounter: EncounterData = encounterData.data;

// Get augmented data with derived fields
const augmentedEncounter = await loadAugmentedEncounter(id);
const creatureTypes = augmentedEncounter?.data.creatureTypes || [];
const usedIn = augmentedEncounter?.data.usedIn || [];
const statBlocks = await getCollection('statBlocks');
const floatingClues = await getCollection('floatingClues');

const title = `Encounter: ${await renderBulletMarkdown(encounter.name)}`;

// Build usage lists from augmented encounter data
const regionsUsing = usedIn.filter((ref) => ref.type === 'region');
const hexesUsing = usedIn.filter((ref) => ref.type === 'hex');
const dungeonsUsing = usedIn.filter((ref) => ref.type === 'dungeon');
const pointcrawlsUsing = usedIn.filter((ref) => ref.type === 'pointcrawl');
const pointcrawlNodesUsing = usedIn.filter((ref) => ref.type === 'pointcrawl-node');
const pointcrawlEdgesUsing = usedIn.filter((ref) => ref.type === 'pointcrawl-edge');

const regionList = regionsUsing
  .map((ref) => `<a href=${getRegionPath(ref.id)}>${ref.name}</a>`)
  .join(', ');
const hexList = hexesUsing
  .map((ref) => `<a href=${getHexPath(ref.id)}>${ref.name}</a>`)
  .join(', ');
const dungeonList = dungeonsUsing
  .map((ref) => `<a href=${getDungeonPath(ref.id)}>${ref.name}</a>`)
  .join(', ');
const pointcrawlList = pointcrawlsUsing
  .map((ref) => `<a href=${getPointcrawlPath(ref.id)}>${ref.name}</a>`)
  .join(', ');
const pointcrawlNodeList = pointcrawlNodesUsing
  .map((ref) => `<a href=${getPointcrawlNodePath(ref.id)}>${ref.name}</a>`)
  .join(', ');
const pointcrawlEdgeList = pointcrawlEdgesUsing
  .map((ref) => `<a href=${getPointcrawlEdgePath(ref.id)}>${ref.name}</a>`)
  .join(', ');

// Floating clues are not tracked in usedIn, so check manually
const floatingCluesUsingEncounter = floatingClues.filter((clue) =>
  clue.data.encounters?.includes(id),
);
const floatingClueList = floatingCluesUsingEncounter
  .map(
    (clue) => `<a href=${getFloatingCluePath(clue.id)}>${clue.data.name}</a>`,
  )
  .join(', ');

// Get all roleplay books
const allRoleplayBooks = await getCollection('roleplay-books');

// Match roleplay books based on keywords in encounter ID or stat block IDs
const statBlockIds = encounter.statBlocks ?? [];
const matchedRoleplayBooks = allRoleplayBooks.filter((book) => {
  const keyword = book.data.keyword;
  // Check if encounter ID contains keyword
  if (id.includes(keyword)) return true;
  // Check if any stat block ID contains keyword
  return statBlockIds.some((statBlockId) => statBlockId.includes(keyword));
});

// Resolve and sort stat blocks by CR (lowest to highest)
const resolvedStatBlocks = statBlockIds
  .map((statBlockId: string) => {
    const statBlock = statBlocks.find((sb) => sb.id === statBlockId);
    if (!statBlock) {
      throw new Error(`Stat block not found: ${statBlockId}`);
    }
    return statBlock;
  })
  .sort((a, b) => (a.data.cr ?? 0) - (b.data.cr ?? 0));
---

<style is:global>
  .description table {
    border-spacing: 0;
    margin-top: 1rem;
  }

  .description td,
  .description th {
    border-bottom: 1px solid var(--bulma-border);
    padding-right: 1rem;
    padding-top: 0.25rem;
    padding-bottom: 0.25rem;
  }

  .description th {
    border-top: 1px solid var(--bulma-border);
  }
</style>
<style>
  .taxonomy-section {
    margin-bottom: 1.5rem;
    padding: 1rem;
    background: var(--bulma-scheme-main-bis);
    border-radius: 6px;
    border: 1px solid var(--bulma-border);
  }

  .taxonomy-row {
    display: flex;
    flex-wrap: wrap;
    gap: 1rem;
    align-items: baseline;
  }

  .taxonomy-item {
    display: flex;
    align-items: baseline;
    gap: 0.5rem;
  }

  .taxonomy-label {
    font-weight: 600;
    font-size: 0.875rem;
    color: var(--bulma-text-weak);
  }

  .taxonomy-badges {
    display: flex;
    flex-wrap: wrap;
    gap: 0.25rem;
  }

  .badge {
    display: inline-block;
    padding: 0.125rem 0.5rem;
    background: var(--bulma-scheme-main-ter);
    border-radius: 3px;
    font-size: 0.875rem;
  }

  .badge.scope {
    background: #dbeafe;
    color: #1e40af;
  }

  .badge.location {
    background: #dcfce7;
    color: #166534;
  }

  .badge.faction {
    background: #ffedd5;
    color: #c2410c;
  }

  .badge.creature {
    background: #f3e8ff;
    color: #7e22ce;
  }

  .badge.lead {
    background: #fce7f3;
    color: #9d174d;
    font-weight: 600;
  }

  /* Dark mode - explicit theme selection */
  :global(html[data-theme='dark']) .badge.scope {
    background: #1e3a5f;
    color: #93c5fd;
  }

  :global(html[data-theme='dark']) .badge.location {
    background: #14532d;
    color: #86efac;
  }

  :global(html[data-theme='dark']) .badge.faction {
    background: #7c2d12;
    color: #fdba74;
  }

  :global(html[data-theme='dark']) .badge.creature {
    background: #581c87;
    color: #d8b4fe;
  }

  :global(html[data-theme='dark']) .badge.lead {
    background: #831843;
    color: #fbcfe8;
  }

  /* Dark mode - system preference when no explicit theme */
  @media (prefers-color-scheme: dark) {
    :global(html:not([data-theme])) .badge.scope {
      background: #1e3a5f;
      color: #93c5fd;
    }

    :global(html:not([data-theme])) .badge.location {
      background: #14532d;
      color: #86efac;
    }

    :global(html:not([data-theme])) .badge.faction {
      background: #7c2d12;
      color: #fdba74;
    }

    :global(html:not([data-theme])) .badge.creature {
      background: #581c87;
      color: #d8b4fe;
    }

    :global(html:not([data-theme])) .badge.lead {
      background: #831843;
      color: #fbcfe8;
    }
  }

  .cross-reference-list {
    margin-bottom: 1rem;
  }

  .stat-block-container section:not(:last-child) {
    border-bottom: 1px solid var(--bulma-body-color);
    margin-bottom: 1rem;
    padding-bottom: 1rem;
  }
</style>
<SecretArticleLayout title={title}>
  {(encounter.scope || encounter.isLead || encounter.locationTypes || encounter.factions || creatureTypes.length > 0) && (
    <div class="taxonomy-section">
      <div class="taxonomy-row">
        {encounter.scope && (
          <div class="taxonomy-item">
            <span class="taxonomy-label">Scope:</span>
            <span class="badge scope">{encounter.scope}</span>
          </div>
        )}

        {encounter.isLead && (
          <div class="taxonomy-item">
            <span class="badge lead">Lead</span>
          </div>
        )}

        {encounter.locationTypes && encounter.locationTypes.length > 0 && (
          <div class="taxonomy-item">
            <span class="taxonomy-label">Location:</span>
            <div class="taxonomy-badges">
              {encounter.locationTypes.map((type) => (
                <span class="badge location">{type}</span>
              ))}
            </div>
          </div>
        )}

        {encounter.factions && encounter.factions.length > 0 && (
          <div class="taxonomy-item">
            <span class="taxonomy-label">Factions:</span>
            <div class="taxonomy-badges">
              {encounter.factions.map((faction) => (
                <span class="badge faction">{faction}</span>
              ))}
            </div>
          </div>
        )}

        {creatureTypes.length > 0 && (
          <div class="taxonomy-item">
            <span class="taxonomy-label">Creatures:</span>
            <div class="taxonomy-badges">
              {creatureTypes.map((type) => (
                <span class="badge creature">{type}</span>
              ))}
            </div>
          </div>
        )}
      </div>
    </div>
  )}

  <ul class="cross-reference-list">
  {
    floatingClueList.length > 0 && (
      <li>
        <strong>Floating Clues</strong> using this encounter:{' '}
        <Fragment set:html={floatingClueList} />
      </li>
    )
  }

  {
    regionList.length > 0 && (
      <li>
        <strong>Regions</strong> with this encounter: <Fragment set:html={regionList} />
      </li>
    )
  }
  {
    hexList.length > 0 && (
      <li>
        <strong>Hexes</strong> with this encounter: <Fragment set:html={hexList} />
      </li>
    )
  }
  {
    dungeonList.length > 0 && (
      <li>
        <strong>Dungeons</strong> with this encounter: <Fragment set:html={dungeonList} />
      </li>
    )
  }
  {
    pointcrawlList.length > 0 && (
      <li>
        <strong>Pointcrawls</strong> with this encounter: <Fragment set:html={pointcrawlList} />
      </li>
    )
  }
  {
    pointcrawlNodeList.length > 0 && (
      <li>
        <strong>Pointcrawl Nodes</strong> with this encounter: <Fragment set:html={pointcrawlNodeList} />
      </li>
    )
  }
  {
    pointcrawlEdgeList.length > 0 && (
      <li>
        <strong>Pointcrawl Edges</strong> with this encounter: <Fragment set:html={pointcrawlEdgeList} />
      </li>
    )
  }
  </ul>
  <Unlocks
    knowledgeTrees={flatKnowledgeTrees}
    unlocks={encounter.unlocks ?? []}
  />
  {
    encounter.description && (
      <div class="summary">
        {encounter.contentPath && <h2 class="title is-3">Summary</h2>}
        <div class="description">
          <Fragment set:html={renderMarkdown(encounter.description)} />
        </div>
      </div>
    )
  }
  {
    encounter.contentPath && (
      <div class="detailed-content">
        {encounter.description && <h2 class="title is-3">Details</h2>}
        <EncounterContent encounterId={id} contentPath={encounter.contentPath} />
      </div>
    )
  }
  <div class="roleplay-books">
    {
      matchedRoleplayBooks.map((entry) => (
        <RoleplayBook data={entry.data} />
      ))
    }
  </div>
  <div class="stat-block-container">
    {
      resolvedStatBlocks.map((statBlock) => (
        <StatBlock data={statBlock.data} />
      ))
    }
  </div>
</SecretArticleLayout>
