---
import { normalizeHexId } from '@achm/core';
import { loadMapConfig } from '@achm/data';
import { getCollection, getEntry } from 'astro:content';

import OpenContent from '../../../components/Content/OpenContent.astro';
import SecretContent from '../../../components/Content/SecretContent.astro';
import GmHexDetails from '../../../components/GmHexDetails/GmHexDetails.svelte';
import PlayerHexDetails from '../../../components/PlayerHexDetails/PlayerHexDetails.astro';
import RandomEncountersSection from '../../../components/RandomEncountersSection.astro';
import RandomEncounterTable from '../../../components/RandomEncounterTable/RandomEncounterTable.astro';
import ComponentLayout from '../../../layouts/ComponentLayout.astro';
import { mergeEncounterOverrides } from '../../../utils/encounters';
import { createSyntheticHex, processHex } from '../../../utils/hexes';
import { buildHexToRegionLookup } from '../../../utils/regions';

import type { EncounterTableData, HexData } from '@achm/schemas';

// Get the ID from the incoming server request
const { id } = Astro.params;
if (!id) {
  return new Response(null, {
    status: 404,
    statusText: 'Not found',
  });
}

// Load map config for notation
const mapConfig = loadMapConfig();
const notation = mapConfig.grid.notation;

// Build region lookup early (needed for both file-based and synthetic hexes)
const regions = await getCollection('regions');
const hexToRegion = buildHexToRegionLookup(regions, notation);

// Try to get hex from file, or create synthetic hex from region
const hexEntry = await getEntry('hexes', id);
let hexData: HexData;

if (hexEntry) {
  hexData = hexEntry.data;
} else {
  // No file exists - check if this hex is defined in a region
  const normalizedId = normalizeHexId(id, notation);
  const regionEntry = hexToRegion.get(normalizedId);

  if (!regionEntry) {
    // Hex doesn't exist as file or in any region
    return new Response(null, {
      status: 404,
      statusText: 'Not found',
    });
  }

  // Create synthetic hex data from region
  hexData = createSyntheticHex(normalizedId, regionEntry.data);
}

const dungeons = await getCollection('dungeons');
const clues = await getCollection('clues');

// Build clue lookup map for display
const clueMap = Object.fromEntries(
  clues.map((c) => [c.id, { id: c.id, name: c.data.name }])
);
const title = `Hex ${hexData.id.toUpperCase()}: ${hexData.name}`;

// Find pointcrawls accessible from this hex
const allPointcrawls = await getCollection('pointcrawls');
const normalizedHexId = normalizeHexId(hexData.id, notation);
const pointcrawls = allPointcrawls
  .filter((p) => p.data.hexIds?.includes(normalizedHexId))
  .map((p) => ({ slug: p.data.slug, name: p.data.name }));

// Find hex's region
const regionEntry = hexToRegion.get(normalizedHexId);

// Resolve hex with regionId and fallback terrain/biome
const hex = {
  ...hexData,
  regionId: regionEntry?.id ?? 'unknown',
  terrain: hexData.terrain ?? regionEntry?.data.terrain,
  biome: hexData.biome ?? regionEntry?.data.biome,
};

// Build the random encounter table
let encounters: EncounterTableData | undefined = undefined;
let encounterChance = 8;
if (regionEntry) {
  encounters = regionEntry.data.encounters;
  encounterChance = regionEntry.data.encounterChance;
}
encounterChance = hex.encounterChance ?? encounterChance;

if (hex.encounterOverrides) {
  if (encounters) {
    encounters = mergeEncounterOverrides(encounters, hex.encounterOverrides);
  } else if (hex.encounterOverrides.mainTable) {
    // Use hex overrides as the full table when no region base exists
    // categoryTables may be empty if all categories use external tableId references
    encounters = {
      mainTable: hex.encounterOverrides.mainTable,
      categoryTables: (hex.encounterOverrides.categoryTables ?? {}) as EncounterTableData['categoryTables'],
    };
  }
}

const extendedHexData = await processHex(hex);
---

<ComponentLayout title={title}>
  <OpenContent>
    <PlayerHexDetails hex={hex} />
  </OpenContent>
  <SecretContent>
    <GmHexDetails
      client:load
      clueMap={clueMap}
      dungeons={dungeons}
      hex={extendedHexData}
      pointcrawls={pointcrawls}
      showSelfLink={false}
    />
    {!hex.hideRandomEncounters && regionEntry && (
      <RandomEncountersSection
        region={regionEntry.data}
        encounters={encounters}
        encounterChance={encounterChance}
      />
    )}
    {!hex.hideRandomEncounters && !regionEntry && encounters && (
      <>
        <h2 class="title is-3" style="margin-bottom: 0.25rem">Random Encounters</h2>
        <p>
          <span class="inline-heading">Chance of encounter:</span>
          {' '}
          {encounterChance * 5}% (&le;{encounterChance})
        </p>
        <RandomEncounterTable data={encounters} />
      </>
    )}
  </SecretContent>
</ComponentLayout>
