---
import { getCollection, getEntry } from 'astro:content';

import OpenContent from '../../../components/Content/OpenContent.astro';
import SecretContent from '../../../components/Content/SecretContent.astro';
import GhostlyEchoes from '../../../components/GhostlyEchoes.astro';
import GmHexDetails from '../../../components/GmHexDetails/GmHexDetails.svelte';
import PlayerHexDetails from '../../../components/PlayerHexDetails/PlayerHexDetails.astro';
import RandomEncounterTable from '../../../components/RandomEncounterTable/RandomEncounterTable.astro';
import { getEncounterPath } from '../../../config/routes';
import ComponentLayout from '../../../layouts/ComponentLayout.astro';
import { loadClueLinks } from '../../../utils/clue-links';
import { mergeEncounterOverrides } from '../../../utils/encounters';
import { processHex } from '../../../utils/hexes';
import { getFlatKnowledgeTrees } from '../../../utils/knowledge-trees';

import type { EncounterTableData, HexData } from '@skyreach/schemas';

const flatKnowledgeTrees = await getFlatKnowledgeTrees();
const clueLinks = await loadClueLinks();

// Get the ID from the incoming server request
const { id } = Astro.params;
if (!id) {
  return new Response(null, {
    status: 404,
    statusText: 'Not found',
  });
}

// Query for the entry directly using the request slug
const hexEntry = await getEntry('hexes', id);

// Redirect if the entry does not exist
if (hexEntry === undefined) {
  return new Response(null, {
    status: 404,
    statusText: 'Not found',
  });
}

const dungeons = await getCollection('dungeons');
const hex: HexData = hexEntry.data;
const title = `Hex ${hex.id.toUpperCase()}: ${hex.name}`;

// Find pointcrawls accessible from this hex
const allPointcrawls = await getCollection('pointcrawls');
const pointcrawls = allPointcrawls
  .filter((p) => p.data.hexIds?.includes(hex.id.toLowerCase()))
  .map((p) => ({ slug: p.data.slug, name: p.data.name }));

// Build the random encounter table
let encounters: EncounterTableData | undefined = undefined;
let encounterChance = 8;
const regions = await getCollection('regions');
const region = regions.find((region) => region.id === hex.regionId);
if (region) {
  encounters = region.data.encounters;
  encounterChance = region.data.encounterChance;
}
encounterChance = hex.encounterChance ?? encounterChance;

if (hex.encounterOverrides) {
  if (encounters) {
    encounters = mergeEncounterOverrides(encounters, hex.encounterOverrides);
  } else if (hex.encounterOverrides.mainTable && hex.encounterOverrides.categoryTables) {
    // Use hex overrides as the full table when no region base exists
    encounters = {
      mainTable: hex.encounterOverrides.mainTable,
      categoryTables: hex.encounterOverrides.categoryTables as EncounterTableData['categoryTables'],
    };
  }
}

const extendedHexData = await processHex(hex);

// Herald encounter logic (inherited from region)
const allEncounters = await getCollection('encounters');
const heraldActive = region && !region.data.heraldComplete && (region.data.heraldEncounters?.length ?? 0) > 0;
const heraldEncounters = heraldActive
  ? (region!.data.heraldEncounters ?? []).map((encId) => {
      const encounter = allEncounters.find((e) => e.data.id === encId)?.data;
      if (!encounter) {
        throw new Error(`Region "${region!.id}" references unknown herald encounter: "${encId}"`);
      }
      return encounter;
    })
  : [];
---

<style>
  .encounters-header {
    display: flex;
    flex-wrap: wrap;
    align-items: flex-end;
    gap: 0.75rem;
    margin-bottom: 0.25rem;
  }

  .encounters-header :global(.title) {
    margin-bottom: 0;
  }

  .herald-banner {
    background-color: #dcfce7;
    border: 1px solid #86efac;
    border-radius: 4px;
    padding: 0.25rem 0.5rem;
    display: inline-block;
    margin-bottom: 0.25rem;
  }

  .herald-banner-text {
    font-weight: 600;
    color: #166534;
  }

  /* Dark mode - explicit theme */
  :global(html[data-theme='dark']) .herald-banner {
    background-color: #14532d;
    border-color: #166534;
  }

  :global(html[data-theme='dark']) .herald-banner-text {
    color: #86efac;
  }

  /* Dark mode - system preference when no explicit theme */
  @media (prefers-color-scheme: dark) {
    :global(html:not([data-theme])) .herald-banner {
      background-color: #14532d;
      border-color: #166534;
    }

    :global(html:not([data-theme])) .herald-banner-text {
      color: #86efac;
    }
  }

  .herald-encounter-list {
    list-style: disc;
    margin-left: 1.5rem;
  }
</style>

<ComponentLayout title={title}>
  <OpenContent>
    <PlayerHexDetails hex={hex} />
  </OpenContent>
  <SecretContent>
    <GmHexDetails
      client:load
      clueLinks={clueLinks}
      dungeons={dungeons}
      hex={extendedHexData}
      knowledgeTrees={flatKnowledgeTrees}
      pointcrawls={pointcrawls}
      showSelfLink={false}
    />
    {!hex.hideRandomEncounters && (
      <>
        <div class="encounters-header">
          <h2 class="title is-3">Random Encounters</h2>
          {heraldActive && (
            <div class="herald-banner">
              <span class="herald-banner-text">Herald Phase Active</span>
            </div>
          )}
        </div>
        {heraldActive ? (
          <>
            <p>
              <span class="inline-heading">Chance of encounter:</span>
              {' '}
              50% (&le;10)
            </p>
            <p><strong>Herald Encounters:</strong></p>
            <ul class="herald-encounter-list">
              {heraldEncounters.map((encounter) => (
                <li>
                  <a href={getEncounterPath(encounter.id)}>{encounter.name}</a>
                </li>
              ))}
            </ul>
          </>
        ) : (
          <>
            <p>
              <span class="inline-heading">Chance of encounter:</span>
              {' '}
              {encounterChance * 5}% (&le;{encounterChance})
            </p>
            <RandomEncounterTable data={encounters} />
          </>
        )}
      </>
    )}
    <GhostlyEchoes isScarSite={hex.tags?.includes('scar-site')} />
  </SecretContent>
</ComponentLayout>
