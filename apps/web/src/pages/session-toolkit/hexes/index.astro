---
import { normalizeHexId } from '@achm/core';
import { loadMapConfig } from '@achm/data';
import { getCollection } from 'astro:content';

import HexSearch from '../../../components/GmHexDetails/HexSearch.svelte';
import SecretLayout from '../../../layouts/SecretLayout.astro';
import { createSyntheticHex, hexSort, processHex, resolveHexWithRegion } from '../../../utils/hexes';
import { buildHexToRegionLookup, getAllRegionHexIds } from '../../../utils/regions';

import type { ExtendedHexData, PointcrawlLink } from '../../../types';

const mapConfig = loadMapConfig();
const notation = mapConfig.grid.notation;

const dungeons = await getCollection('dungeons');
const hexEntries = await getCollection('hexes');
const regionEntries = await getCollection('regions');

// Build region lookup
const hexToRegion = buildHexToRegionLookup(regionEntries, notation);

// Get all hex IDs from regions and identify those without individual files
const allRegionHexIds = getAllRegionHexIds(regionEntries, notation);
const hexFileIds = new Set(
  hexEntries.map((e) => normalizeHexId(e.data.id, notation)),
);

// Create synthetic hex data for region hexes without files
const syntheticHexes = [...allRegionHexIds]
  .filter((hexId) => !hexFileIds.has(hexId))
  .map((hexId) => {
    const region = hexToRegion.get(hexId)!;
    return createSyntheticHex(hexId, region.data);
  });

// Combine file-based and synthetic hexes, resolve with region data
const allHexData = [
  ...hexEntries.map((e) => e.data),
  ...syntheticHexes,
];

const intermediateHexes = allHexData
  .map((hex) => {
    const region = hexToRegion.get(normalizeHexId(hex.id, notation));
    return resolveHexWithRegion(hex, region);
  })
  .sort((a, b) => hexSort(a, b, notation))
  .filter((hex) => !hex.hideInCatalog);

const hexes: ExtendedHexData[] = await Promise.all(
  intermediateHexes.map(processHex),
);

// Build map of hexId -> pointcrawls for that hex
const allPointcrawls = await getCollection('pointcrawls');
const pointcrawlsByHex: Record<string, PointcrawlLink[]> = {};
for (const pc of allPointcrawls) {
  for (const hexId of pc.data.hexIds ?? []) {
    if (!pointcrawlsByHex[hexId]) {
      pointcrawlsByHex[hexId] = [];
    }
    pointcrawlsByHex[hexId].push({ slug: pc.data.slug, name: pc.data.name });
  }
}
---

<SecretLayout title="Hex Catalog">
  <HexSearch
    client:load
    dungeons={dungeons}
    hexes={hexes}
    mapConfig={mapConfig}
    pointcrawlsByHex={pointcrawlsByHex}
  />
</SecretLayout>
