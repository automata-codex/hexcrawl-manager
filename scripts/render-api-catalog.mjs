#!/usr/bin/env node
/**
 * Render a single-page API catalog from TypeDoc's JSON output.
 *
 * Input:  docs/api/typedoc.json     (generated by `typedoc --json docs/api/typedoc.json`)
 * Output: docs/api/CATALOG.md
 *
 * How to run:
 *   node scripts/render-api-catalog.mjs
 */

import fs from "node:fs";
import path from "node:path";

/* -------------------------- Config (tweak as needed) -------------------------- */

const INPUT_JSON = process.env.TYPEDOC_JSON || "docs/api/typedoc.json";
const OUTPUT_MD  = process.env.API_CATALOG || "docs/api/CATALOG.md";

// TypeDoc ReflectionKind numbers we care about
const KIND = {
  Enum: 16,
  Variable: 32,
  Function: 64,
  Class: 128,
  Interface: 256,
  TypeAlias: 2097152,
};

const KIND_NAME = new Map([
  [KIND.Enum, "Enum"],
  [KIND.Variable, "Variable"],
  [KIND.Function, "Function"],
  [KIND.Class, "Class"],
  [KIND.Interface, "Interface"],
  [KIND.TypeAlias, "Type alias"],
]);

// Which kinds to include at top-level (others are ignored or summarized)
const INCLUDE_KINDS = new Set([
  KIND.Function,
  KIND.TypeAlias,
  KIND.Variable,
  KIND.Enum,
  KIND.Class,
  KIND.Interface,
]);

/* ------------------------------ Helper: reading ------------------------------- */

function readTypedocJson(file) {
  const raw = fs.readFileSync(file, "utf8");
  const json = JSON.parse(raw);
  return json;
}

function indexById(project) {
  const map = new Map();
  function walk(n) {
    if (!n || typeof n !== "object") return;
    if (typeof n.id === "number") map.set(n.id, n);
    if (Array.isArray(n.children)) n.children.forEach(walk);
    if (Array.isArray(n.signatures)) n.signatures.forEach(walk);
    if (n.type?.declaration) walk(n.type.declaration);
    if (Array.isArray(n.groups)) n.groups.forEach(walk);
  }
  walk(project);
  return map;
}

/* --------------------------- Helpers: doc rendering --------------------------- */

function textFromComment(comment) {
  if (!comment) return "";
  // typedoc 0.24+ uses comment.summary: Array<{kind, text}>
  const parts = Array.isArray(comment.summary) ? comment.summary : [];
  const text = parts.map(p => p.text ?? "").join("").trim();
  // if empty, fallback to older shape comment.shortText
  return text || (comment.shortText?.trim() ?? "");
}

function codeInline(s) {
  return s.replace(/`/g, "\\`");
}

function mdEscape(s) {
  return s.replace(/[<>]/g, c => ({ "<": "&lt;", ">": "&gt;" }[c]));
}

function getNodeComment(node) {
  // Prefer node.comment (e.g., variables, type aliases)
  if (node?.comment) return node.comment;

  // Functions: the docs usually live on the first signature
  const sig = (node?.signatures ?? [])[0];
  if (sig?.comment) return sig.comment;

  // Some variables/types can carry docs inside a reflection type declaration
  if (node?.type?.declaration?.comment) return node.type.declaration.comment;

  return undefined;
}

/* --------------------------- Type rendering (pretty) -------------------------- */

function renderType(t) {
  if (!t) return "any";
  switch (t.type) {
    case "intrinsic": return t.name;
    case "reference":
      return t.typeArguments?.length
        ? `${t.name}<${t.typeArguments.map(renderType).join(", ")}>`
        : t.name;
    case "array": return `${renderType(t.elementType)}[]`;
    case "union": return t.types.map(renderType).join(" | ");
    case "intersection": return t.types.map(renderType).join(" & ");
    case "tuple": return `[${t.elements?.map(renderType).join(", ") ?? ""}]`;
    case "literal":
      if (typeof t.value === "string") return JSON.stringify(t.value);
      if (t.value === null) return "null";
      return String(t.value);
    case "reflection": {
      const decl = t.declaration;
      if (!decl) return "object";
      // render inline object type `{ a: string; b?: number }`
      const parts = [];
      (decl.children ?? []).forEach((c) => {
        const opt = c.flags?.isOptional ? "?" : "";
        parts.push(`${c.name}${opt}: ${renderType(c.type)}`);
      });
      // call signatures as function type? (rare at top-level)
      const sig = (decl.signatures ?? [])[0];
      if (sig) {
        const params = (sig.parameters ?? []).map(p => `${p.name}${p.flags?.isOptional ? "?" : ""}: ${renderType(p.type)}`).join(", ");
        return `(${params}) => ${renderType(sig.type)}`;
      }
      return `{ ${parts.join("; ")} }`;
    }
    case "query": return `${renderType(t.queryType)}`;
    case "conditional":
      return `${renderType(t.checkType)} extends ${renderType(t.extendsType)} ? ${renderType(t.trueType)} : ${renderType(t.falseType)}`;
    case "indexedAccess":
      return `${renderType(t.objectType)}[${renderType(t.indexType)}]`;
    case "templateLiteral":
      // `${head}${(types[i])}${tail[i]}...`
      return "`" + [t.head, ...(t.tail ?? [])].map((chunk, i) => {
        const hole = t.types?.[i] ? "${" + renderType(t.types[i]) + "}" : "";
        return hole + chunk;
      }).join("") + "`";
    default:
      return "unknown";
  }
}

/* ---------------------------- Signature rendering ---------------------------- */

function renderFunctionSignature(node) {
  const sig = (node.signatures ?? [])[0];
  if (!sig) return `function ${node.name}(...): any`;
  const params = (sig.parameters ?? []).map(p => {
    const opt = p.flags?.isOptional ? "?" : "";
    const rest = p.flags?.isRest ? "..." : "";
    const typeStr = renderType(p.type);
    return `${rest}${p.name}${opt}: ${typeStr}`;
  }).join(", ");
  const ret = renderType(sig.type);
  return `function ${node.name}(${params}): ${ret}`;
}

function renderTypeAliasSignature(node) {
  return `type ${node.name} = ${renderType(node.type)};`;
}

function renderVariableSignature(node) {
  // const/let is lost; assume const for docs
  return `const ${node.name}: ${renderType(node.type)};`;
}

function renderEnumSignature(node) {
  const members = (node.children ?? []).map(m => m.name).join(", ");
  return `enum ${node.name} { ${members} }`;
}

function renderInterfaceHeader(node) {
  const typeParams = (node.typeParameters ?? []).map(tp => tp.name).join(", ");
  return `interface ${node.name}${typeParams ? `<${typeParams}>` : ""}`;
}

function renderClassHeader(node) {
  const typeParams = (node.typeParameters ?? []).map(tp => tp.name).join(", ");
  return `class ${node.name}${typeParams ? `<${typeParams}>` : ""}`;
}

/* ------------------------------- Tree utilities ------------------------------ */

function eachTopLevelExport(entry) {
  // TypeDoc’s entry children are usually modules/namespaces with exports beneath.
  // We collect unique exported symbols under each entry point.
  const out = [];
  const visited = new Set();

  function visit(n, depth = 0) {
    if (!n || typeof n !== "object") return;
    const kind = n.kindString;
    const exported = true; // TypeDoc JSON doesn’t always carry isExported; we treat top-level children as exports.

    if (exported && INCLUDE_KINDS.has(kind) && !visited.has(n.id)) {
      visited.add(n.id);
      out.push(n);
    }
    if (Array.isArray(n.children)) n.children.forEach(c => visit(c, depth + 1));
    if (Array.isArray(n.signatures)) n.signatures.forEach(s => visit(s, depth + 1));
    if (n.type?.declaration) visit(n.type.declaration, depth + 1);
  }

  visit(entry, 0);
  // De-duplicate by name/kind (best-effort)
  const dedup = new Map();
  for (const n of out) {
    dedup.set(`${n.kindString}:${n.name}`, n);
  }
  return [...dedup.values()].sort((a, b) => a.name.localeCompare(b.name, "en", { numeric: true }));
}

/* --------------------------------- Rendering -------------------------------- */

function renderNodeLine(n) {
  let code;
  switch (n.kind) {
    case KIND.Function:   code = renderFunctionSignature(n); break;
    case KIND.TypeAlias:  code = renderTypeAliasSignature(n); break;
    case KIND.Variable:   code = renderVariableSignature(n); break;
    case KIND.Enum:       code = renderEnumSignature(n); break;
    case KIND.Interface:  code = renderInterfaceHeader(n); break;
    case KIND.Class:      code = renderClassHeader(n); break;
    default: return null;
  }

  const summary = textFromComment(getNodeComment(n));
  return `- \`${mdEscape(code)}\`${summary ? ` — ${summary}` : ""}`;
}

function renderEntrySection(entry, byId) {
  const lines = [];
  lines.push(`\n## ${entry.name}\n`);

  const ids = entry.groups?.flatMap(g => g.children ?? []) ?? [];
  const nodes = (ids.length ? ids.map(id => byId.get(id)) : (entry.children ?? []))
    .filter(Boolean)
    .filter(n => INCLUDE_KINDS.has(n.kind))                 // <— use numeric kind
    .sort((a, b) => a.name.localeCompare(b.name, "en", { numeric: true }));

  if (!nodes.length) {
    lines.push("_(no exported symbols found)_");
    return lines;
  }

  for (const n of nodes) {
    const line = renderNodeLine(n);
    if (line) lines.push(line);
  }
  return lines;
}

/* ------------------------------------ Main ----------------------------------- */

function main() {
  if (!fs.existsSync(INPUT_JSON)) {
    console.error(`❌ Cannot find TypeDoc JSON at: ${INPUT_JSON}`);
    process.exit(1);
  }
  const project = readTypedocJson(INPUT_JSON);
  const byId = indexById(project);

  const lines = [];
  lines.push("# Skyreach API Catalog\n");
  lines.push("_Single-file catalog generated from TypeDoc JSON. Edits will be overwritten._\n");

  const entries = project.children ?? [project];
  for (const entry of entries) {
    console.error("ENTRY:", entry.name,
      "groups:", entry.groups?.length ?? 0,
      "children:", entry.children?.length ?? 0);
    lines.push(...renderEntrySection(entry, byId));
  }

  fs.mkdirSync(path.dirname(OUTPUT_MD), { recursive: true });
  fs.writeFileSync(OUTPUT_MD, lines.join("\n") + "\n", "utf8");
  console.log(`✔ Wrote ${OUTPUT_MD} (${lines.length} lines)`);
}

main();
