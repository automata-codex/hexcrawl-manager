---
import type { DungeonEntry, HexEntry, RegionData } from '../../types';
import { allRarities, initialRarityCounts } from '../../utils/magic-items';

interface Props {
  dungeons: DungeonEntry[],
  hexData: HexEntry[],
  region: RegionData,
}

const { dungeons, hexData, region } = Astro.props;

const treasureRatingDescriptions = {
  1: 'Very Low (250–500 gp, no or 1 consumable item)',
  2: 'Low (500–1,000 gp, 1–2 common items)',
  3: 'Moderate (1,000–2,000 gp, 2–3 uncommon items)',
  4: 'High (2,000–4,000 gp, 3–5 items, including rare)',
  5: 'Very High (4,000+ gp, multiple rare or very rare items)',
} as const;

const dungeonItems = dungeons
  .filter(dungeon => {
    const hex = hexData.find(hex => hex.data.id === dungeon.data.hexId);
    return hex && hex.data.regionId === region.id;
  })
  .flatMap(dungeon => Array.isArray(dungeon.data.magicItems) ? dungeon.data.magicItems : [])
  .filter(item => typeof item === 'object' && item.rarity)
  .reduce((acc, item) => {
    acc[item.rarity] = (acc[item.rarity] || 0) + 1;
    return acc;
  }, { ...initialRarityCounts });
const dungeonTreasure = dungeons
  .filter(dungeon => {
    const hex = hexData.find(hex => hex.data.id === dungeon.data.hexId);
    return hex && hex.data.regionId === region.id;
  })
  .reduce((total, dungeon) => total + (dungeon.data.treasureValue || 0), 0);

// I don't like casting to `any[]`, but it's the only way I've found to make the types work in here
const hiddenSiteItems = hexData
  .filter(hex => hex.data.regionId === region.id)
  .flatMap(hex => hex.data.hiddenSites as any[] || [])
  .flatMap(site =>
    typeof site !== 'string' && Array.isArray(site.treasure)
      ? site.treasure.filter((item: {type: string}) => item.type === 'magic-item')
      : []
  )
  .filter(item => typeof item === 'object' && item.rarity)
  .reduce((acc, item) => {
    acc[item.rarity] = (acc[item.rarity] || 0) + 1;
    return acc;
  }, { ...initialRarityCounts });
const hiddenSiteTreasure = hexData
  .filter(hex => hex.data.regionId === region.id)
  .flatMap(hex => hex.data.hiddenSites as any[] || [])
  .reduce((total, site) => total + ((typeof site !== 'string' && site.treasureValue) || 0), 0);


const totalItemCounts = allRarities.reduce((acc, rarity) => {
  acc[rarity] = (hiddenSiteItems[rarity] || 0) + (dungeonItems[rarity] || 0);
  return acc;
}, { ...initialRarityCounts });
const totalTreasureValue = hiddenSiteTreasure + dungeonTreasure;
---
<p class="hanging-indent">
  <span class="inline-heading">Treasure Rating:</span>{' '}
  {region.treasureRating} – {treasureRatingDescriptions[region.treasureRating as 1 | 2 | 3 | 4 | 5]}
</p>
<p class="hanging-indent">
  <span class="inline-heading">Total treasure value:</span>{' '}
  {totalTreasureValue.toLocaleString()} gp
</p>
<p class="hanging-indent">
  <span class="inline-heading">Magic items:</span>{' '}
  {Object.entries(totalItemCounts)
    .filter(([_, count]) => count > 0)
    .map(([rarity, count]) => `${count} ${rarity}`)
    .join(', ')}
</p>
