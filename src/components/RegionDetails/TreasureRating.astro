---
import type { ArticleEntry, DungeonEntry, HexEntry, RegionData, TreasureData } from '../../types';
import { allRarities, initialRarityCounts, type Rarity } from '../../utils/magic-items';

interface Props {
  articles: ArticleEntry[],
  dungeons: DungeonEntry[],
  hexData: HexEntry[],
  region: RegionData,
}

const { articles, dungeons, hexData, region } = Astro.props;

const treasureRatingDescriptions = {
  1: 'Very Low (250–500 gp, no or 1 consumable item)',
  2: 'Low (500–1,000 gp, 1–2 common items)',
  3: 'Moderate (1,000–2,000 gp, 2–3 uncommon items)',
  4: 'High (2,000–4,000 gp, 3–5 items, including rare)',
  5: 'Very High (4,000+ gp, multiple rare or very rare items)',
} as const;

const articleItems = articles
  .filter(article => article.data.treasureRegionId === region.id)
  .flatMap(article => {
    const treasure = article.data.treasure
    if (!treasure || typeof treasure !== 'object') return []
    return Object.values(treasure) as TreasureData[];
  })
  .filter(item => typeof item === 'object' && item.type === 'magic-item' && item.rarity)
  .reduce<Record<string, number>>((acc, item: any) => {
    acc[item.rarity] = (acc[item.rarity] || 0) + 1
    return acc
  }, {});
const articleTreasure = articles
  .filter(article => article.data.treasureRegionId === region.id)
  .reduce((total, article) => {
    const treasureMap = article.data.treasure;
    if (!treasureMap || typeof treasureMap !== 'object') return total;

    const valueFromMap = Object.values(treasureMap)
      .filter(item => typeof item === 'object' && typeof item.value === 'number')
      .reduce((sum, item: any) => sum + item.value, 0);

    return total + valueFromMap;
  }, 0);

const dungeonItems = dungeons
  .filter(dungeon => {
    const hex = hexData.find(hex => hex.data.id === dungeon.data.hexId);
    return hex && hex.data.regionId === region.id;
  })
  .flatMap(dungeon => {
    const treasureItems = Array.isArray(dungeon.data.treasure)
      ? dungeon.data.treasure.filter(item => item.type === 'magic-item')
      : Array.isArray(dungeon.data.magicItems)
        ? dungeon.data.magicItems
        : [];
    return treasureItems as { rarity: Rarity; }[];
  })
  .filter(item => typeof item === 'object' && item.rarity)
  .reduce((acc, item) => {
    acc[item.rarity] = (acc[item.rarity] || 0) + 1;
    return acc;
  }, { ...initialRarityCounts });
const dungeonTreasure = dungeons
  .filter(dungeon => {
    const hex = hexData.find(hex => hex.data.id === dungeon.data.hexId);
    return hex && hex.data.regionId === region.id;
  })
  .reduce((total, dungeon) => {
    const treasureItems = dungeon.data.treasure;
    const calculatedValue = Array.isArray(treasureItems)
      ? treasureItems.reduce((sum, item) => sum + (item.value || 0), 0)
      : (dungeon.data.treasureValue || 0);
    return total + calculatedValue;
  }, 0);

const hiddenSiteItems = hexData
  .filter(hex => hex.data.regionId === region.id)
  // I don't like casting to `any[]`, but it's the only way I've found to make the types work in here
  .flatMap(hex => hex.data.hiddenSites as any[] || [])
  .flatMap(site =>
    typeof site !== 'string' && Array.isArray(site.treasure)
      ? site.treasure.filter((item: {type: string}) => item.type === 'magic-item')
      : []
  )
  .filter(item => typeof item === 'object' && item.rarity)
  .reduce((acc, item) => {
    acc[item.rarity] = (acc[item.rarity] || 0) + 1;
    return acc;
  }, { ...initialRarityCounts });
const hiddenSiteTreasure = hexData
  .filter(hex => hex.data.regionId === region.id)
  .flatMap(hex => hex.data.hiddenSites as any[] || [])
  .reduce((total, site) => {
    if (typeof site !== 'string' && Array.isArray(site.treasure)) {
      const siteTotal = site.treasure.reduce(
        (sum: number, item: TreasureData) => sum + (item.value || 0),
        0
      );
      return total + siteTotal;
    }
    return total;
  }, 0);

const totalItemCounts = allRarities.reduce((acc, rarity) => {
  acc[rarity] = (articleItems[rarity] || 0) + (hiddenSiteItems[rarity] || 0) + (dungeonItems[rarity] || 0);
  return acc;
}, { ...initialRarityCounts });
const totalTreasureValue = articleTreasure + hiddenSiteTreasure + dungeonTreasure;
---
<p class="hanging-indent">
  <span class="inline-heading">Treasure Rating:</span>{' '}
  {region.treasureRating} – {treasureRatingDescriptions[region.treasureRating as 1 | 2 | 3 | 4 | 5]}
</p>
<p class="hanging-indent">
  <span class="inline-heading">Total treasure value:</span>{' '}
  {totalTreasureValue.toLocaleString()} gp
</p>
<p class="hanging-indent">
  <span class="inline-heading">Magic items:</span>{' '}
  {Object.entries(totalItemCounts)
    .filter(([_, count]) => count > 0)
    .map(([rarity, count]) => `${count} ${rarity}`)
    .join(', ')}
</p>
