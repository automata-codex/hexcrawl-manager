---
import { getCollection, getEntry } from 'astro:content';

import GmHexDetails from '../../../components/GmHexDetails/GmHexDetails.svelte';
import PlayerHexDetails from '../../../components/PlayerHexDetails/PlayerHexDetails.astro';
import RandomEncounterTable from '../../../components/RandomEncounterTable/RandomEncounterTable.astro';
import OpenContent from '../../../components/Content/OpenContent.astro';
import SecretContent from '../../../components/Content/SecretContent.astro';
import ComponentLayout from '../../../layouts/ComponentLayout.astro';
import type {
  CategoryTableData,
  EncounterOverrideData,
  EncounterTableData,
  HexData,
} from '../../../types';
import { processHex } from '../../../utils/hexes';
import { knowledgeTrees } from '../../../utils/knowledge-trees';

// Get the ID from the incoming server request
const { id } = Astro.params;
if (!id) {
  return new Response(null, {
    status: 404,
    statusText: 'Not found'
  });
}

// Query for the entry directly using the request slug
const hexData = await getEntry('hexes', id);

// Redirect if the entry does not exist
if (hexData === undefined) {
  return new Response(null, {
    status: 404,
    statusText: 'Not found'
  });
}

const dungeons = await getCollection('dungeons');
const hex: HexData = hexData.data;
const title = `Hex ${hex.id.toUpperCase()}: ${hex.name}`;

// Build the random encounter table
let encounters: EncounterTableData | undefined = undefined;
let encounterChance = 8;
const regions = await getCollection('regions');
const region = regions.find(region => region.id === hex.regionId);
if (region) {
  encounters = region.data.encounters;
  encounterChance = region.data.encounterChance;
}
encounterChance = hex.encounterChance ?? encounterChance;

export function mergeHexOverrides(
  base: EncounterTableData,
  overrides?: EncounterOverrideData
): EncounterTableData {
  if (!overrides) return base;

  // Use the override mainTable if provided, otherwise keep base
  const mainTable = overrides.mainTable ?? base.mainTable;

  const categoryTables: CategoryTableData = structuredClone(base.categoryTables);

  if (overrides.categoryTables) {
    for (const [category, tierOverrides] of Object.entries(overrides.categoryTables)) {
      categoryTables[category] = categoryTables[category] || {};

      for (const [tier, overrideEntries] of Object.entries(tierOverrides ?? {})) {
        categoryTables[category][tier] = overrideEntries;
      }
    }
  }

  return {
    mainTable,
    categoryTables,
  };
}

if (encounters && hex.encounterOverrides) {
  encounters = mergeHexOverrides(encounters, hex.encounterOverrides);
}

const extendedHexData = await processHex(hex);
---
<ComponentLayout title={title}>
  <OpenContent>
    <PlayerHexDetails hex={hex} />
  </OpenContent>
  <SecretContent>
    <GmHexDetails
      client:load
      dungeons={dungeons}
      hex={extendedHexData}
      knowledgeTrees={knowledgeTrees}
      showSelfLink={false}
    />
    <h2 class="title is-3" style="margin-bottom: 0.25rem">Random Encounters</h2>
    <p>
      <span class="inline-heading">Chance of encounter:</span>
      {' '}
      {encounterChance * 5}%
      (&le;{encounterChance})
    </p>
    <RandomEncounterTable data={encounters} />
  </SecretContent>
</ComponentLayout>
